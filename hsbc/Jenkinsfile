#!/usr/bin/env groovy


def keepThisBuildIfMaster() {
    currentBuild.setKeepLog(true)
    currentBuild.setDescription("Test Description")
}

def getShortCommitHash() {
    return sh(returnStdout: true, script: "git log -n 1 --pretty=format:'%h'").trim()
}

def getChangeAuthorName() {
    return sh(returnStdout: true, script: "git show -s --pretty=%an").trim()
}

def getChangeAuthorEmail() {
    return sh(returnStdout: true, script: "git show -s --pretty=%ae").trim()
}

def getChangeSet() {
    return sh(returnStdout: true, script: 'git diff-tree --no-commit-id --name-status -r HEAD').trim()
}

def getChangeLog() {
    return sh(returnStdout: true, script: "git log --date=short --pretty=format:'%ad %aN <%ae> %n%n%x09* %s%d%n%b'").trim()
}

def getCurrentBranch () {
    return sh (
            script: 'git rev-parse --abbrev-ref HEAD',
            returnStdout: true
    ).trim()
}

def isPRMergeBuild() {
    return (env.BRANCH_NAME ==~ /^PR-\d+$/)
}

def notifyBuild(String buildStatus = 'STARTED') {
    // build status of null means successful
    buildStatus = buildStatus ?: 'SUCCESS'

    def branchName = getCurrentBranch()
    def shortCommitHash = getShortCommitHash()
    def changeAuthorName = getChangeAuthorName()
    def changeAuthorEmail = getChangeAuthorEmail()
    def changeSet = getChangeSet()
    def changeLog = getChangeLog()

    // Default values
    def colorName = 'RED'
    def colorCode = '#FF0000'
    def subject = "${buildStatus}: '${env.JOB_NAME} [${env.BUILD_NUMBER}]'" + branchName + ", " + shortCommitHash
    def summary = "Started: Name:: ${env.JOB_NAME} \n " +
            "Build Number: ${env.BUILD_NUMBER} \n " +
            "Build URL: ${env.BUILD_URL} \n " +
            "Short Commit Hash: " + shortCommitHash + " \n " +
            "Branch Name: " + branchName + " \n " +
            "Change Author: " + changeAuthorName + " \n " +
            "Change Author Email: " + changeAuthorEmail + " \n " +
            "Change Set: " + changeSet

    if (buildStatus == 'STARTED') {
        color = 'YELLOW'
        colorCode = '#FFFF00'
    } else if (buildStatus == 'SUCCESS') {
        color = 'GREEN'
        colorCode = '#00FF00'
    } else {
        color = 'RED'
        colorCode = '#FF0000'
    }

    // Send notifications
    hipchatSend(color: color, notify: true, message: summary, token: "${env.HIPCHAT_TOKEN}",
        failOnError: true, room: "${env.HIPCHAT_ROOM}", sendAs: 'Jenkins', textFormat: true)if (buildStatus == 'FAILURE') {
        emailext attachLog: true, body: summary, compressLog: true, recipientProviders: [brokenTestsSuspects(), brokenBuildSuspects(), culprits()], replyTo: 'noreply@yourdomain.com', subject: subject, to: 'mpatel@yourdomain.com'
    }
}

pipeline {
    agent none;

    environment {
        BUILD_NUMBER = "${env.BUILD_NUMBER}"
        REPO_URL = '<Some repository URL>'
    }

    options {
        timestamps()
        retry(3)
        timeout time:30, unit:'MINUTES'
    }

    parameters {
        string(defaultValue: "develop", description: 'Branch Specifier', name: 'SPECIFIER')
        booleanParam(defaultValue: false, description: 'Deploy to QA Environment ?', name: 'DEPLOY_QA')
        booleanParam(defaultValue: false, description: 'Deploy to UAT Environment ?', name: 'DEPLOY_UAT')
        booleanParam(defaultValue: false, description: 'Deploy to PROD Environment ?', name: 'DEPLOY_PROD')
    }

    triggers {
        cron('@weekly')
    }

    // Begin stages of pipeline.
    stages {
        stage("Initialize Environment") {
            agent any;
            steps {
                script {
                    notifyBuild('STARTED')
                    echo "${BUILD_NUMBER} - ${env.BUILD_ID} on ${env.JENKINS_URL}"
                    echo "Branch Specifier :: ${params.SPECIFIER}"
                    echo "Deploy to QA? :: ${params.DEPLOY_QA}"
                    echo "Deploy to UAT? :: ${params.DEPLOY_UAT}"
                    echo "Deploy to PROD? :: ${params.DEPLOY_PROD}"
                    sh 'rm -rf target/universal/*.zip'
                }
            }
        }

        stage('Checkout') {
            agent any;
            steps {
                checkout scm;
            }
        }

        stage('Build') {
            agent any;
            steps {
                echo 'Run coverage and CLEAN UP Before please'
                sh '/usr/local/bin/opt/bin/sbtGitActivator; /usr/local/bin/opt/play-2.5.10/bin/activator -Dsbt.global.base=.sbt -Dsbt.ivy.home=/home/jenkins/.ivy2 -Divy.home=/home/jenkins/.ivy2 compile coverage test coverageReport coverageOff dist'
            }
        }

        stage('Standard Development Testing') {
            agent any;

            parallel {
                stage('Unit testing') {
                    // ...
                }

                stage('Function testing') {
                    // ...
                }

                stage('Integration testing') {
                    // ...
                }
            }

            post {
                always {
                    // Run the steps in the post section regardless of the completion
                    // status of the Pipeline’s or stage’s run.
                    echo "Development testing on ${env.NODE_NAME} completed."
                }
                failure {
                    // Only run the steps in post if the current Pipeline’s or stage’s run has
                    // a "failed" status, typically denoted by red in the web UI.
                    echo "A failure was captured on node: ${env.NODE_NAME}"
                    getCapturedFailures()
                }

                aborted {
                    // Only run the steps in post if the current Pipeline’s or stage’s run
                    // has an "aborted" status, usually due to the Pipeline being manually
                    // aborted. This is typically denoted by gray in the web UI.
                }

                success {
                    // Only run the steps in post if the current Pipeline’s or stage’s run has a
                    // "success" status, typically denoted by blue or green in the web UI.
                }

                unstable {
                    // Only run the steps in post if the current Pipeline’s or stage’s run has an
                    // "unstable" status, usually caused by test failures, code violations, etc.
                    // This is typically denoted by yellow in the web UI.
                }


            }
        }
        
        stage('Global Development Testing') {
            agent { label: 'Mexico-ZOS_1-Dev' }
            agent { label: 'UK-Sheffield-ZOS_1-Dev' }
            agent { label: 'HK-ZOS_1-Dev' }

            parallel {
                stage('Unit testing') {
                    // ...
                }

                stage('Function testing') {
                    // ...
                }

                stage('Integration testing') {
                    // ...
                }
            }


        }

        stage('Production Testing') {
            agent { label: 'Mexico-ZOS_2-Prod' }
            agent { label: 'UK-Sheffield-ZOS_2-Prod' }
            agent { label: 'HK-ZOS_2-Prod' }

            parallel {
                stage('Smoke Testing') {
                    // ...
                }
    
                stage('Unit testing') {
                    // ...
                }

                stage('Function testing') {
                    // ...
                }

                stage('Integration testing') {
                    // ...
                }
            }
        }

        stage('ITSA Verification') {
            agent any;

            parallel {
                stage('Follows <Rule 1>') {
                    // ...
                }

                stage('Follows <Rule 2>') {
                    // ...
                }
                // Other rules...
            }
        }

        stage('Publish Reports') {
            parallel {
                stage('Publish Code Quality Report') {
                    steps {
                        // Determine code quality with some capture metrics...
                    }
                }
                stage('Publish FindBugs Report') {
                    steps {
                        step([$class: 'FindBugsPublisher', canComputeNew: false, defaultEncoding: '', excludePattern: '', healthy: '', includePattern: '', pattern: 'target/scala-2.11/findbugs/report.xml', unHealthy: ''])
                    }
                }
                stage('Publish Test XML Report') {
                    steps {
                        junit allowEmptyResults: true, testResults: 'target/test-reports/*.xml'
                    }
                }
                stage('Publish Test HTML Report') {
                    steps {
                        publishHTML target: [
                                allowMissing: true,
                                alwaysLinkToLastBuild: false,
                                keepAll: true,
                                reportDir: 'target/reports/html',
                                reportFiles: 'index.html',
                                reportName: 'Test Suite HTML Report'
                        ]
                    }
                }
                stage('Publish Code Coverage HTML Report') {
                    steps {
                        publishHTML target: [
                                allowMissing: true,
                                alwaysLinkToLastBuild: false,
                                keepAll: true,
                                reportDir: 'target/scala-2.11/scoverage-report',
                                reportFiles: 'index.html',
                                reportName: 'Code Coverage'
                        ]
                    }
                }
                stage('Execute Whitesource Analysis') {
                    steps {
                        whitesource jobApiToken: '', jobCheckPolicies: 'global', jobForceUpdate: 'global', libExcludes: '', libIncludes: '', product: "${env.WS_PRODUCT_TOKEN}", productVersion: '', projectToken: "${env.WS_PROJECT_TOKEN}", requesterEmail: ''
                    }
                }
                // Security integration
                stage('SonarQube analysis') {
                    steps {
                        sh "/usr/bin/sonar-scanner"
                    }
                }
                // Cache artifacts.
                stage('Archive artifacts') {
                    steps {
                        archiveArtifacts '**/target/universal/*.zip'
                    }
                }
            }
        }
    
        stage('Deploy') {
            agent { label: 'Mexico-ZOS_2-Prod' }
            agent { label: 'UK-Sheffield-ZOS_2-Prod' }
            agent { label: 'HK-ZOS_2-Prod' }

            when {
                branch 'master'
            }

            parallel {
                stage('Deploy to QA') {
                    when {
                        expression {
                            params.DEPLOY_QA == true
                        }
                    }
                    steps {
                        echo "Deploy to QA..."
                    }
                }

                stage('Deploy to Production') {
                    when {
                        expression {
                            params.DEPLOY_PROD == true
                        }
                    }
                    steps {
                        echo "Deploy to PROD..."
                        // Do some deployment step(s).
                    }
                }
            }
        }

        stage('Teardown & Cleanup') {
            agent any;
            when {
                expression {
                    return env.NODE_NAME.toString().contains('prod') != true;
                }
            }
            steps {
                // Teardown and cleanup steps here...
            }
        }
    }

    post {
        /*
         * These steps will run at the end of the pipeline based on the condition.
         * Post conditions run in order regardless of their place in the pipeline
         * 1. always - always run
         * 2. changed - run if something changed from the last run
         * 3. aborted, success, unstable or failure - depending on the status
         */
        always {
            echo "I AM ALWAYS first"
            echo "Pipeline done"
            notifyBuild("${currentBuild.currentResult}")
        }
        aborted {
            echo "BUILD ABORTED"
        }
        success {
            echo "BUILD SUCCESS"
            echo "Keep Current Build If branch is master"
            keepThisBuildIfMaster()
        }
        unstable {
            echo "BUILD UNSTABLE"
        }
        failure {
            echo "BUILD FAILURE"
        }
    }
}