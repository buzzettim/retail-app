#!/usr/bin/env bash


THIS_DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" >/dev/null 2>&1 && pwd )";
NEW_PROC_PID="";


kill_node_instances() {
  # grep is not feature complete on the share system (missing flags
  # like "-o") and we don't have pgrep, so we will use basic grep/
  # awk features to capture running node instances.
  node_instances="$(ps -ef | awk '/node/ {print $2}')";

  if [[ -z "$node_instances" ]]; then
    printf "No running Node instances found.\n"
  else
    printf "Existing node processes found.\n"
    printf "Killing $(echo $node_instances | wc -w | awk '{$1=$1};1') PIDs...\n";
    for pid in $node_instances; do kill -9 $pid; done
  fi
}


# Set up log directory and corresponding files to redirect output.
setup_logs() {
  printf "Making directories and files for piped output...\n";
  mkdir -p logs;
  touch logs/stderr.log;
  touch logs/stdout.log;
  printf "Made directories and files for piped output.\n";
}


# Start a script as a background process. Expects the first argument to
# be a Bash command to execute. The background process is started with
# the "&" character.
start_script() {
  export NODE_ENV=production;
  export NODE_PORT=3000;

  node_script="node $THIS_DIR/www &";
  printf "Starting Node server in background...\n";

  # Set up log directories/files.
  setup_logs;
  
  # Start script. Capture started ID and print it to the user
  # for debugging purposes.
  eval $node_script;
  NEW_PROC_PID="$!"

  printf "New server process started with ID: $NEW_PROC_ID";

  return 0;
}


main () {
  # Get all active node instances
  kill_node_instances;
  start_script;
  exit 0;
}



main "$@"